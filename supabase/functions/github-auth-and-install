import { serve } from 'https://deno.land/std@0.168.0/http/server.ts';
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';
const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type'
};
serve(async (req)=>{
  // Handle CORS preflight requests
  if (req.method === 'OPTIONS') {
    return new Response('ok', {
      headers: corsHeaders
    });
  }
  try {
    // Get environment variables
    const supabaseUrl = Deno.env.get('SUPABASE_URL');
    const supabaseServiceKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY');
    const githubAppId = Deno.env.get('GITHUB_APP_ID');
    const githubAppPrivateKey = Deno.env.get('GITHUB_APP_PRIVATE_KEY');
    const githubClientId = Deno.env.get('GITHUB_CLIENT_ID');
    const githubClientSecret = Deno.env.get('GITHUB_CLIENT_SECRET');
    if (!supabaseUrl || !supabaseServiceKey || !githubAppId || !githubAppPrivateKey || !githubClientId || !githubClientSecret) {
      throw new Error('Missing required environment variables');
    }
    // Initialize Supabase client with service role
    const supabaseAdmin = createClient(supabaseUrl, supabaseServiceKey);
    // Parse request body
    const body = await req.json();
    const { code, installation_id, state, intent, redirect_uri } = body;
    console.log('Processing GitHub auth callback:', {
      code: code ? 'present' : 'missing',
      installation_id,
      hasState: !!state,
      hasIntent: !!intent
    });
    // ADDED: Parse state to determine flow type
    let flowType = 'signup'; // default
    if (state) {
      try {
        // Handle both string and object state parameters
        let parsedState;
        if (typeof state === 'string') {
          parsedState = JSON.parse(decodeURIComponent(state));
        } else {
          parsedState = state; // Already an object
        }
        flowType = parsedState.flow_type || 'signup';
        console.log('Detected flow type:', flowType);
      } catch (error) {
        console.warn('Failed to parse state parameter:', error);
        // Fallback: check if it's already an object
        if (typeof state === 'object' && state.flow_type) {
          flowType = state.flow_type;
          console.log('Used object state fallback, flow type:', flowType);
        }
      }
    }
    // Step 1: Exchange authorization code for access token
    console.log('Step 1: Exchanging code for access token');
    const tokenResponse = await fetch('https://github.com/login/oauth/access_token', {
      method: 'POST',
      headers: {
        'Accept': 'application/json',
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        client_id: githubClientId,
        client_secret: githubClientSecret,
        code,
        redirect_uri
      })
    });
    if (!tokenResponse.ok) {
      throw new Error(`Failed to exchange code for token: ${tokenResponse.statusText}`);
    }
    const tokenData = await tokenResponse.json();
    if (tokenData.error) {
      throw new Error(`GitHub OAuth error: ${tokenData.error_description || tokenData.error}`);
    }
    const accessToken = tokenData.access_token;
    if (!accessToken) {
      throw new Error('No access token received from GitHub');
    }
    // Step 2: Get user information from GitHub
    console.log('Step 2: Fetching user info from GitHub');
    const userResponse = await fetch('https://api.github.com/user', {
      headers: {
        'Authorization': `Bearer ${accessToken}`,
        'Accept': 'application/vnd.github.v3+json'
      }
    });
    if (!userResponse.ok) {
      throw new Error(`Failed to fetch user info: ${userResponse.statusText}`);
    }
    const githubUser = await userResponse.json();
    // Get user's primary email if not public
    let userEmail = githubUser.email;
    if (!userEmail) {
      const emailResponse = await fetch('https://api.github.com/user/emails', {
        headers: {
          'Authorization': `Bearer ${accessToken}`,
          'Accept': 'application/vnd.github.v3+json'
        }
      });
      if (emailResponse.ok) {
        const emails = await emailResponse.json();
        const primaryEmail = emails.find((email)=>email.primary);
        userEmail = primaryEmail?.email || `${githubUser.login}@github.local`;
      }
    }
    if (!userEmail) {
      userEmail = `${githubUser.login}@github.local`;
    }
    console.log('GitHub user info:', {
      id: githubUser.id,
      login: githubUser.login,
      email: userEmail,
      name: githubUser.name
    });
    // Step 3: Create or update Supabase user
    console.log('Step 3: Creating/updating Supabase user');
    // Prepare user metadata
    const userMetadata = {
      github_id: githubUser.id,
      login: githubUser.login,
      name: githubUser.name || githubUser.login,
      avatar_url: githubUser.avatar_url,
      bio: githubUser.bio,
      location: githubUser.location,
      company: githubUser.company,
      provider: 'github'
    };
    // First check if user already exists
    const { data: existingUsers, error: lookupError } = await supabaseAdmin.auth.admin.listUsers();
    let supabaseUser = null;
    if (!lookupError && existingUsers.users) {
      supabaseUser = existingUsers.users.find((u)=>u.email === userEmail || u.user_metadata?.github_id === githubUser.id);
    }
    if (supabaseUser) {
      console.log('User already exists, updating metadata:', supabaseUser.id);
      // Update existing user metadata
      const { data: updateData, error: updateError } = await supabaseAdmin.auth.admin.updateUserById(supabaseUser.id, {
        user_metadata: userMetadata
      });
      if (updateError) {
        console.warn('Failed to update user metadata:', updateError);
      } else {
        supabaseUser = updateData.user;
      }
    } else {
      console.log('Creating new user');
      // Create new user in Supabase Auth using Admin API
      const { data: authData, error: authError } = await supabaseAdmin.auth.admin.createUser({
        email: userEmail,
        email_confirm: true,
        user_metadata: userMetadata,
        app_metadata: {
          provider: 'github',
          github_id: githubUser.id
        }
      });
      if (authError) {
        throw new Error(`Failed to create user: ${authError.message}`);
      }
      supabaseUser = authData.user;
    }
    if (!supabaseUser) {
      throw new Error('Failed to create or retrieve user');
    }
    console.log('Supabase user created/retrieved:', supabaseUser.id);
    // Step 4: Create user profile
    console.log('Step 4: Creating user profile');
    const userName = intent?.name || githubUser.name || githubUser.login || 'User';
    const userRole = intent?.role || 'developer';
    const { error: profileError } = await supabaseAdmin.rpc('create_user_profile', {
      user_id: supabaseUser.id,
      user_email: userEmail,
      user_name: userName,
      user_role: userRole,
      company_name: intent?.company_name || ''
    });
    if (profileError) {
      console.warn('Profile creation RPC failed:', profileError);
      // Try direct insert as fallback
      const { error: insertError } = await supabaseAdmin.from('users').upsert({
        id: supabaseUser.id,
        email: userEmail,
        name: userName,
        role: userRole,
        is_approved: userRole === 'developer',
        company_name: userRole === 'recruiter' ? intent?.company_name || '' : null,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      }, {
        onConflict: 'id'
      });
      if (insertError) {
        throw new Error(`Failed to create user profile: ${insertError.message}`);
      }
    }
    // Step 5: Create/Update developer profile if user is a developer
    let developerProfile = null;
    if (userRole === 'developer') {
      console.log('Step 5: Creating/updating developer profile');
      // ADDED: For login flow, fetch existing installation ID
      let installationIdToUse = installation_id ? parseInt(installation_id) : null;
      if (flowType === 'login' && !installation_id) {
        console.log('Login flow detected, fetching existing installation ID');
        const { data: existingDev, error: fetchError } = await supabaseAdmin.from('developers').select('github_installation_id').eq('user_id', supabaseUser.id).single();
        if (!fetchError && existingDev?.github_installation_id) {
          installationIdToUse = parseInt(existingDev.github_installation_id);
          console.log('Preserved existing installation ID:', installationIdToUse);
        } else if (fetchError && fetchError.code !== 'PGRST116') {
          console.warn('Error fetching existing developer profile:', fetchError);
        }
      }
      const developerData = {
        user_id: supabaseUser.id,
        github_handle: githubUser.login,
        bio: githubUser.bio || '',
        location: githubUser.location || '',
        profile_pic_url: githubUser.avatar_url,
        github_installation_id: installationIdToUse?.toString() || null,
        availability: true
      };
      console.log('Developer data to upsert:', {
        ...developerData,
        github_installation_id: developerData.github_installation_id ? 'preserved/provided' : 'null'
      });
      const { data: devProfile, error: devError } = await supabaseAdmin.from('developers').upsert(developerData, {
        onConflict: 'user_id'
      }).select().single();
      if (devError) {
        console.warn('Developer profile creation failed:', devError);
      } else {
        developerProfile = devProfile;
        console.log('Developer profile created/updated:', devProfile.id);
      }
    }
    // Step 6: Generate session for the user (CORRECTED VERSION)
    console.log('Step 6: Generating user session');
    let sessionResponse = null;
    try {
      // Generate magic link using admin client
      console.log('Generating magic link for session creation');
      const { data: magicLinkData, error: magicLinkError } = await supabaseAdmin.auth.admin.generateLink({
        type: 'magiclink',
        email: userEmail,
        options: {
          redirectTo: `${new URL(redirect_uri).origin}/auth/github-callback`
        }
      });
      if (magicLinkError) {
        console.warn('Magic link generation failed:', magicLinkError);
      } else if (magicLinkData?.properties?.hashed_token) {
        console.log('Magic link generated successfully, verifying token');
        // Verify the OTP token to create a session
        const { data: verifyData, error: verifyError } = await supabaseAdmin.auth.verifyOtp({
          token_hash: magicLinkData.properties.hashed_token,
          type: 'email'
        });
        if (verifyError) {
          console.warn('Token verification failed:', verifyError);
        } else if (verifyData.session) {
          sessionResponse = verifyData.session;
          console.log('Successfully created session via magic link verification');
        } else {
          console.warn('Token verification succeeded but no session returned');
        }
      } else {
        console.warn('Magic link generated but no hashed_token received');
      }
    } catch (error) {
      console.warn('Magic link session creation failed:', error);
    }
    // Alternative method: Generate invite link if magic link fails
    if (!sessionResponse) {
      console.log('Trying alternative session creation with invite link');
      try {
        const { data: inviteData, error: inviteError } = await supabaseAdmin.auth.admin.generateLink({
          type: 'invite',
          email: userEmail,
          options: {
            redirectTo: `${new URL(redirect_uri).origin}/auth/github-callback`
          }
        });
        if (!inviteError && inviteData?.properties?.hashed_token) {
          console.log('Invite link generated, verifying token');
          const { data: verifyInviteData, error: verifyInviteError } = await supabaseAdmin.auth.verifyOtp({
            token_hash: inviteData.properties.hashed_token,
            type: 'invite'
          });
          if (!verifyInviteError && verifyInviteData.session) {
            sessionResponse = verifyInviteData.session;
            console.log('Successfully created session via invite verification');
          } else {
            console.warn('Invite verification failed:', verifyInviteError);
          }
        } else {
          console.warn('Invite link generation failed:', inviteError);
        }
      } catch (altError) {
        console.warn('Invite method also failed:', altError);
      }
    }
    console.log('Authentication flow completed successfully');
    const response = {
      success: true,
      user: {
        id: supabaseUser.id,
        email: userEmail,
        name: userName,
        role: userRole
      },
      developer_profile: developerProfile,
      installation_id: installation_id
    };
    // Include session if we have valid tokens
    if (sessionResponse?.access_token && sessionResponse?.refresh_token) {
      response.session = {
        access_token: sessionResponse.access_token,
        refresh_token: sessionResponse.refresh_token,
        expires_at: sessionResponse.expires_at,
        expires_in: sessionResponse.expires_in,
        token_type: sessionResponse.token_type || 'bearer'
      };
      console.log('Session tokens included in response');
    } else {
      response.message = 'User created successfully. Please sign in to continue.';
      console.log('No session tokens available, user will need to sign in manually');
    }
    return new Response(JSON.stringify(response), {
      headers: {
        ...corsHeaders,
        'Content-Type': 'application/json'
      }
    });
  } catch (error) {
    console.error('GitHub auth error:', error);
    return new Response(JSON.stringify({
      error: error.message || 'Authentication failed',
      details: error.stack
    }), {
      status: 400,
      headers: {
        ...corsHeaders,
        'Content-Type': 'application/json'
      }
    });
  }
});
